
<!-- saved from url=(0056)http://www.sidefx.com/docs/houdini12.0/nodes/sop/lsystem -->
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:w="http://whoosh.ca/ns/wiki/1.2/" xmlns:f="http://sidefx.com/ns/xslt/functions"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>L-system </title><link href="http://www.sidefx.com/docs/houdini12.0/css/page.css" rel="stylesheet"><link href="http://www.sidefx.com/docs/houdini12.0/css/highlight.css" rel="stylesheet"><link href="http://www.sidefx.com/docs/houdini12.0/css/jquery.searchbox.css" rel="stylesheet"><link rel="icon" href="http://www.sidefx.com/icons/small/SOP/lsystem.png"><script type="text/javascript" src="./L-system_files/load_example"> </script><script type="text/javascript" src="resource:///res/RunHCommand.js"> </script><script type="text/javascript" src="./L-system_files/jquery.js"> </script><script type="text/javascript" src="./L-system_files/jquery.searchbox.js"> </script><script type="text/javascript" src="./L-system_files/jquery.dimensions.js"> </script><script type="text/javascript" src="./L-system_files/jquery.highlight-3.yui.js"> </script><script type="text/javascript" src="./L-system_files/page.js"> </script><script type="text/javascript" src="./L-system_files/load.js"> </script></head><body class="node"><div id="topui"><table id="parents"><tbody><tr><td class="parent"><a style="background-image: url(&quot;../../icons/small/DESKTOP/application.png&quot;)" class=" iconlink" href="http://www.sidefx.com/docs/houdini12.0/" title="">Houdini 12</a> </td><td class="parent"><a style="background-image: url(&quot;../../icons/small/PANETYPES/network.png&quot;)" class=" iconlink" href="http://www.sidefx.com/docs/houdini12.0/nodes/" title="">Nodes</a> </td><td class="parent"><a style="background-image: url(&quot;../../icons/small/OBJ/geo.png&quot;)" class=" iconlink" href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/" title="Nodes that control the shape of geometry.">Surface nodes</a> </td><td id="lastparent"> </td></tr></tbody></table></div><form action="http://www.google.com/cse" id="cse-search-box"><div><input type="hidden" name="cx" value="001106583893786776783:cltcdiuhnqe"><input type="hidden" name="ie" value="UTF-8"><input type="text" name="q" size="31" style="border: 1px solid rgb(126, 157, 185); padding: 2px; background-image: url(http://www.google.com/cse/intl/en/images/google_custom_search_watermark.gif); background-color: rgb(255, 255, 255); background-position: 0% 50%; background-repeat: no-repeat no-repeat;"><input type="submit" name="sa" value="Search"></div><input name="siteurl" type="hidden" value="www.sidefx.com/docs/houdini12.0/nodes/sop/lsystem"><input name="ref" type="hidden" value="www.google.com.hk/"><input name="ss" type="hidden" value=""></form><script type="text/javascript" src="./L-system_files/brand">
			// This comment prevents the wiki2html translator from collapsing the opening and closing 'script' tags into one.  Collapsed script tags do not work on all browsers.
		    </script><div id="main"><div id="header"><div id="title"><h1 class="" style="background-image:url(&quot;../../icons/large/SOP/lsystem.png&quot;)">L-system<span class="posttitle"> surface node</span></h1></div> </div><div id="container"><div id="content"><p class="summary">Creates fractal geometry from the recursive application of simple rules.</p><div class="heading" id="id551994"><h2>About L-systems</h2><div class="headingcontent"><p>L-systems (<em>Lindenmayer-systems</em>, named after Aristid Lindenmayer,
1925-1989), allow definition of complex shapes through the use of
iteration. They use a mathematical language in which an initial string
of characters is matched against rules which are evaluated repeatedly,
and the results are used to generate geometry. The result of each
evaluation becomes the basis for the next iteration of geometry, giving
the illusion of growth.
</p><p>The <a href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/">L-system SOP</a> lets you simulate complex organic
structures such as trees, lightning, snowflakes, flowers, and other
branching phenomena.
</p> </div></div><div class="heading" id="includeme"><h2>Placing an L-System in the viewer</h2><div class="headingcontent"><table class="tasktable normal"><tbody><tr><th class="taskheading">To...</th><th class="actionheading">Do this</th></tr><tr><td class="taskcell">Place the L-System anywhere in the scene </td><td class="actioncell"><ol><li><p>Click the <img src="./L-system_files/lsystem.png"> <a href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/">L-System</a> tool on the <strong class="ui">Create</strong> tab.
</p></li><li><p>Move the cursor into the <a href="http://www.sidefx.com/docs/houdini12.0/ref/views/3dview">scene view</a>. 
</p><div class="alert note"><p class="alerttitle">Note <span>
 </span></p><div class="alertcontent"><p>You can hold <span class="keys"><span class="key">Alt</span></span> to detach the L-System from the construction plane.
</p> </div></div></li><li><p>Click <span class="keys"><img src="./L-system_files/LMB.png" alt="LMB" title="LMB"></span> to place the L-System anywhere in the <a href="http://www.sidefx.com/docs/houdini12.0/ref/views/3dview">scene view</a> and press <span class="keys"><span class="key">Enter</span></span> to confirm your selection. 
</p><p>If you press <span class="keys"><span class="key">Enter</span></span> without clicking, Houdini places the L-System at the origin.
</p></li></ol> </td></tr><tr><td class="taskcell">Place the L-System at the origin </td><td class="actioncell"><p>Press <span class="keys"><span class="key">Ctrl</span> + <img src="./L-system_files/LMB.png" alt="LMB" title="LMB"></span> on the <img src="./L-system_files/lsystem.png"> <a href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/">L-System</a> tool on the <a href="http://www.sidefx.com/docs/houdini12.0/shelf">shelf</a>.
</p> </td></tr></tbody></table><p><span class=""><img src="./L-system_files/lsystem(1).png" title="" class=""></span>
</p><div class="alert note"><p class="alerttitle">Note <span> </span>
 </p><div class="alertcontent"><p>L-systems can be moved once they are placed by either dragging them in the scene view or changing the values in the <a href="http://www.sidefx.com/docs/houdini12.0/ref/panes/parms">parameter editor</a>.
</p> </div></div><p>Default L-Systems can be chosen from the <img src="./L-system_files/gear.png"> Gear drop-down menu at the geometry level.
</p><div class="heading" id="id603486"><h3>L-System Handles</h3><div class="headingcontent"><p>The L-System does not have its own rotation parameters; however, you can rotate it at the object level using the handles in the <a href="http://www.sidefx.com/docs/houdini12.0/ref/views/3dview">scene view</a> or by adding a <img src="./L-system_files/xform.png"><a href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/xform">Transform</a> node at the geometry level.
</p><div class="alert note"><p class="alerttitle">Note <span>
 </span></p><div class="alertcontent"><p>The origin of the L-System is at the base of the tree, not the middle of the object.
</p> </div></div> </div></div> </div></div><div class="heading" id="basics"><h2>L-system basics</h2><div class="headingcontent"><div class="heading" id="id472957"><h3>Fractal properties</h3><div class="headingcontent"><p>There are several factors which combine to organize plant structures
and contribute to their beauty. These include:
</p><ul><li><p>symmetry
</p></li><li><p>self-similarity
</p></li><li><p>developmental algorithms
</p></li></ul><p>With L-systems, we are mostly concerned with the latter two.
Self-similarity implies an underlying fractal structure which is
provided through strings of L-systems. Benoit Mandelbrot describes
self-similarity as follows:
</p><p>“When each piece of a shape is geometrically similar to the whole,
both the shape and the cascade that generate it are called
self-similar.”
</p><p>L-systems provide a grammar for describing the growth of
self-similar structures in time. L-system rules determine the
underlying structures of growth in a way that is analogous to the
way that DNA is thought to determine biological growth. This growth
relies on the principle of self-similarity to provide extremely
compact descriptions of complex surfaces.
</p> </div></div><div class="heading" id="id593060"><h3>Rewriting</h3><div class="headingcontent"><p>The central concept of L-systems is <em>rewriting</em>. This works by
recursively replacing an initial state (the <em>initiator</em>) with
rewritten geometry (the <em>generator</em>), reduced and displaced to have
the same end points as those of the interval being replaced.
</p><p>In 1968, Astrid Lindenmayer introduced a string rewriting mechanism
termed “L-systems”. The grammar of L-systems is unique in that the
method of applying productions is applied in parallel and
simultaneously replaces all letters in a given “word”.
</p><p>The simplest example of a rewriting grammar is where two “words” or
strings are used, built from the two letters: <code>a</code> and <code>b</code>, which may
occur many times in a string. Each letter is associated with a
rewriting rule. The rule <code>a = ab</code> means that the letter <code>a</code> is to be
replaced by the string <code>ab</code>, and the rule <code>b = a</code> means that the
letter <code>b</code> is to be replaced by <code>a</code>.
</p><p>If we start the process with the letter <code>b</code> (the <em>premise</em>), and
follow it through in time, we see a certain pattern emerges by
following the rewriting rules:
</p><p><span class=""><img src="./L-system_files/Houdini-03-1-089.jpg" title="" class=""></span>
</p> </div></div><div class="heading" id="id595662"><h3>Production rule syntax</h3><div class="headingcontent"><p>The general form of an L-system rule is:
</p><pre class="highlight">[left_context&lt;] symbol [&gt;right_context] [:condition]=replacement [:probability]
</pre><p>Where...
</p><table class="dl"><tbody><tr class="defn"><td class="dt ">left_context
 </td><td class="dd "><p>An optional string that must precede the <var>symbol</var> for this rule to
match.
</p> </td></tr><tr class="defn"><td class="dt ">symbol
 </td><td class="dd "><p>The symbol to replace. For example, if the symbol is <code>A</code>,
occurrences of <code>A</code> in the initial string will be replaced with
<var>replacement</var> (if this rule matches).
</p> </td></tr><tr class="defn"><td class="dt ">right_context
 </td><td class="dd "><p>An optional string that must follow the <var>symbol</var> for this rule to
match.
</p> </td></tr><tr class="defn"><td class="dt ">condition
 </td><td class="dd "><p>An optional expression that must be true for this rule to match.
</p> </td></tr><tr class="defn"><td class="dt ">replacement
 </td><td class="dd "><p>The string that will replace the <var>symbol</var> (if this rule matches).
</p> </td></tr><tr class="defn"><td class="dt ">probability
 </td><td class="dd "><p>The optional chance (between 0 and 1) that this rule will be executed.
For example, using <code>0.8</code> means this rule will execute 80% of the time.
</p> </td></tr></tbody></table><div class="alert tip"><p class="alerttitle">Tip <span>
 </span></p><div class="alertcontent"><p>You can use <code>-&gt;</code> in production rules instead of <code>=</code>. The meaning is
identical.
</p> </div></div> </div></div><div class="heading" id="id532930"><h3>Turtle commands</h3><div class="headingcontent"><p>We can combine this string-manipulation system with a graphics
routine that interprets the strings as commands for a drawing
“turtle” with a position (XYZ) and heading (angle). By following the
commands, the turtle traces out a shape as it moves.
</p><p>Examples of simple turtle commands:
</p><table class="dl"><tbody><tr class="defn"><td class="dt "><code>F</code> 
 </td><td class="dd "><p>Move forward a step, drawing a line connecting the previous
position to the new position.
</p> </td></tr><tr class="defn"><td class="dt "><code>f</code> 
 </td><td class="dd "><p>Move forward without drawing.
</p> </td></tr><tr class="defn"><td class="dt "><code>+</code> 
 </td><td class="dd "><p>Rotate right 90 degrees.
</p> </td></tr><tr class="defn"><td class="dt "><code>-</code> 
 </td><td class="dd "><p>Rotate left 90 degrees.
</p> </td></tr></tbody></table><p>(In the actual L-system node, the angle of the <code>+</code> and <code>-</code> commands
is configurable.)
</p><p>With these simple rules, we can easily come up with a string that
causes the turtle to draw a shape such as the letter “L”. For
example, assuming the turtle is initially facing upwards, we would
use the following string to create the letter “L”:
</p><p><span class=""><img src="./L-system_files/Houdini-03-1-090.jpg" title="" class=""></span>
</p> </div></div><div class="heading" id="id534708"><h3>Rewriting turtle command strings</h3><div class="headingcontent"><p>By iteratively running a turtle command string through rewrite
rules, you can generate surprisingly complex geometry. The power of
self-reference in rewrite rules can create extremely intricate
figures.
</p><p>As a very simple example of self-reference, consider an L-system
with the initial string <code>A</code> and the rule <code>A=F+A</code>. The rule means
“Wherever you see 'A', replace it with 'F+A'”. Because the
replacement will contains within it the trigger for the rule, each
generation will cause the string to grow in a <em>cascade effect</em>:
</p><p><span class=""><img src="./L-system_files/Houdini-03-1-092.jpg" title="" class=""></span>
</p><p>This generates a growing list of repeated “move forward, then turn”
commands. With a turn angle less than 90 and a sufficient number of
generations, this L-system will approximate an arc or circle. You
could use this behavior as the basis for curling a sheet of paper or
curling a scorpion’s tail. Or, you could randomize the turn angle
and create a squiggly line, which you could use as the basis for a
bolt of lightning.
</p><p>(Be sure not to confuse the turtle command string <code>F+A</code> with the
mathematical statement <em>F plus A</em>. In the context of L-systems, the
<code>+</code> symbol means “turn”, not “add”.)
</p><p>Another example: the following figure is called a <em>quadratic Koch
    island</em>. Beginning with these values:
</p><table class="normal"><tbody><tr><td> Initial string (premise)</td><td><p><code>F-F-F-F</code>
</p></td></tr><tr><td> Rewrite rule</td><td><p><code>F = F-F+F+FF-F-F+F</code>
</p></td></tr><tr><td> Angle</td><td><p><code>90</code>
</p></td></tr></tbody></table><p>...the turtle generates the following for three generations:
</p><flipbook><ul><li><p><span class=""><img src="./L-system_files/island1.png" title="" class=""></span>
</p></li><li><p><span class=""><img src="./L-system_files/island2.png" title="" class=""></span>
</p></li><li><p><span class=""><img src="./L-system_files/island3.png" title="" class=""></span>
</p></li></ul></flipbook><div class="alert note"><p class="alerttitle">Note <span>
 </span></p><div class="alertcontent"><p>The work required for Houdini to calculate successive
generations increases exponentially. If you try the island
example in Houdini, make sure the <strong class="ui">Generations</strong> parameter is
not greater than <code>3</code>.
</p> </div></div><div class="alert tip"><p class="alerttitle">Tip <span>
 </span></p><div class="alertcontent"><p>You can press <span class="keys"><img src="./L-system_files/MMB.png" alt="MMB" title="MMB"></span> on an L-system node to see the node’s
current string. This can be very useful in debugging
rule substitution.
</p> </div></div> </div></div><div class="heading" id="id516060"><h3>Branches</h3><div class="headingcontent"><p>The systems described so far generate a single continuous line. To
describe things like trees, we need a way to create <em>branches</em>.
</p><p>In L-systems, you create branches with the square brackets (<code>[</code> and
<code>]</code>). Any turtle commands you put inside square brackets are
executed separately from the main string by a new turtle.
</p><p>For example, the turtle commands <code>F [+F] F [+F] [-F]</code> is interpreted
as:
</p><ol><li><p>Go forward.
</p></li><li><p>Branch off a new turtle and have it turn right and then go
forward.
</p></li><li><p>Go forward.
</p></li><li><p>Branch off a new turtle and have it turn right and then go
forward.
</p></li><li><p>Branch off a new turtle and have it turn left and then go
forward.
</p></li></ol><p>This creates the following figure:
</p><p><span class=""><img src="./L-system_files/Houdini-03-1-095.jpg" title="" class=""></span>
</p><p>Another example: the command string <code>F [+F] [-F] F [+F] -FF</code> creates
the following figure:
</p><p><span class=""><img src="./L-system_files/Houdini-03-1-096.jpg" title="" class=""></span>
</p> </div></div><div class="heading" id="id603489"><h3>3D</h3><div class="headingcontent"><p>The systems described so far generate flat geometry.
</p><p>To move the turtle in 3D, you use the <code>&amp;</code> (pitch up), <code>^</code> (pitch
down), <code>\</code> (roll clockwise), and <code>/</code> (roll counter-clockwise)
commands.
</p><p>For example, the initial premise <code>FFFA</code> and the rule <code>A= " [&amp;FFFA]
//// [&amp;FFFA] //// [&amp;FFFA]</code>.
</p><p><span class=""><img src="./L-system_files/Houdini-03-1-099.jpg" title="" class=""></span>
</p><p>This creates the following 3D figure:
</p><flipbook><ul><li><p><span class=""><img src="./L-system_files/roll1.png" title="" class=""></span>
</p></li><li><p><span class=""><img src="./L-system_files/roll2.png" title="" class=""></span>
</p></li><li><p><span class=""><img src="./L-system_files/roll3.png" title="" class=""></span>
</p></li><li><p><span class=""><img src="./L-system_files/roll4.png" title="" class=""></span>
</p></li><li><p><span class=""><img src="./L-system_files/roll5.png" title="" class=""></span>
</p></li></ul></flipbook><p>The rule creates three branches at every generation. The pitch up
commands (<code>&amp;</code>) split the branches off from the vertical. The roll
commands (<code>/</code>) make the branches go out in different directions.
(Note the <code>A</code> at the end of each branch that ensures new copies of
the rule will grow from the ends of the branches.)
</p><p>The <code>"</code> command makes the <code>F</code> commands half length in each
generation, which makes the branches shrink further out.
</p> </div></div><div class="heading" id="id617963"><h3>Use multiple L-system rules</h3><div class="headingcontent"><p>In the previous section we used the rule
<code>A= " [&amp;FFFA] //// [&amp;FFFA] //// [&amp;FFFA]</code>.
</p><p>Obviously this rule has redundancy. Since L-systems are about
replacing symbols with strings, we can simply replace the repeated
strings with a new symbol, and then create a new rule for that
symbol:
</p><table class="normal"><tbody><tr><td> Rule 1</td><td><p><code>A= " [B] //// [B] //// [B]</code>
</p></td></tr><tr><td> Rule 2</td><td><p><code>B= &amp;FFFA</code>
</p></td></tr></tbody></table><p>Because the branches are now defined in one place, if you want to
change the branch instructions you only need to edit one string.
</p><p><strong>Note that the two-rule system will take <em>twice as many
    generations</em> to produce the same result</strong>. This is because each
generation performs one rule substitution.
</p><p>So, whereas the single rule <code>A= " [&amp;FFFA] //// [&amp;FFFA] //// [&amp;FFFA]</code>
grows by expanding <code>A</code> at each generation, the dual rules of
<code>A= " [B] //// [B] //// [B]</code> and <code>B= &amp;FFFA</code> work by alternating
between replacing <code>A</code> with <code>" [B] //// [B] //// [B]</code> and replacing
<code>B</code> with <code>&amp;FFFA</code>.
</p> </div></div> </div></div><div class="heading" id="id512001"><h2>Turtle command reference</h2><div class="headingcontent"><p>Normally turtle symbols use the current length/angle/thickness etc. to
determine their effect. You can provide explicit arguments in brackets
to override the normal values used by the turtle command.
</p><p>The following list shows the bracketed arguments. Remember that you can
simply use the single-character command without the arguments and
Houdini will simply use the normal values.
</p><table class="dl"><tbody><tr class="defn"><td class="dt "><code>F(l,w,s,d)</code> 
 </td><td class="dd "><p>Move forward (creating geometry) distance <var>l</var> of width <var>w</var>
using <var>s</var> cross sections of <var>d</var> divisions each.
</p> </td></tr><tr class="defn"><td class="dt "><code>H(l,w,s,d)</code> 
 </td><td class="dd "><p>Move forward half the length (creating geometry) distance <var>l</var>
of width <var>w</var> using <var>s</var> cross sections of <var>d</var> divisions
each.
</p> </td></tr><tr class="defn"><td class="dt "><code>G(l,w,s,d)</code> 
 </td><td class="dd "><p>Move forward but don’t record a vertex distance <var>l</var> of width
<var>w</var> using <var>s</var> cross sections of <var>d</var> divisions each.
</p> </td></tr><tr class="defn"><td class="dt "><code>f(l,w,s,d)</code> 
 </td><td class="dd "><p>Move forward (no geometry created) distance <var>l</var> of width <var>w</var>
using <var>s</var> cross sections of <var>d</var> divisions each.
</p> </td></tr><tr class="defn"><td class="dt "><code>h(l,w,s,d)</code> 
 </td><td class="dd "><p>Move forward a half length (no geometry created) distance <var>l</var>
of width <var>w</var> using <var>s</var> cross sections of <var>d</var> divisions
each.
</p> </td></tr><tr class="defn"><td class="dt "><code>J(s,x,a,b,c) K(s,x,a,b,c) M(s,x,a,b,c)</code> 
 </td><td class="dd "><p>Copy geometry from leaf input J, K, or M at the turtle’s
position after scaling and reorienting the geometry. The
geometry is scaled by the s parameter (default Step Size) and
stamped with the values <var>a</var> through <var>c</var> (default no
stamping). Stamping occurs if the given parameter is present and
the relevant Leaf parameter is set. The <var>x</var> parameter is not
used and should be set to 0. Note that point vector attributes in the
leaf inputs will be affected by the turtle movements. 
</p> </td></tr><tr class="defn"><td class="dt "><code>T(g)</code> 
 </td><td class="dd "><p>Apply tropism vector (gravity). This angles the turtle towards
the negative Y axis. The amount of change is governed by <var>g</var>.
The default change is to use the Gravity parameter.
</p> </td></tr><tr class="defn"><td class="dt "><code>+(a)</code> 
 </td><td class="dd "><p>Turn right <var>a</var> degrees. Default Angle.
</p> </td></tr><tr class="defn"><td class="dt "><code>-(a)</code> 
 </td><td class="dd "><p>Turn left <var>a</var> degrees (minus sign). Default Angle.
</p> </td></tr><tr class="defn"><td class="dt "><code>&amp;(a)</code> 
 </td><td class="dd "><p>Pitch up <var>a</var> degrees. Default Angle.
</p> </td></tr><tr class="defn"><td class="dt "><code>^(a)</code> 
 </td><td class="dd "><p>Pitch down <var>a</var> degrees. Default Angle.
</p> </td></tr><tr class="defn"><td class="dt "><code>\(a)</code> 
 </td><td class="dd "><p>Roll clockwise <var>a</var> degrees. Default Angle.
</p> </td></tr><tr class="defn"><td class="dt "><code>/(a)</code> 
 </td><td class="dd "><p>Roll counter-clockwise <var>a</var> degrees. Default Angle.
</p> </td></tr><tr class="defn"><td class="dt "><code>|</code> 
 </td><td class="dd "><p>Turn 180 degrees
</p> </td></tr><tr class="defn"><td class="dt "><code>*</code> 
 </td><td class="dd "><p>Roll 180 degrees
</p> </td></tr><tr class="defn"><td class="dt "><code>~(a)</code> 
 </td><td class="dd "><p>Pitch / Roll / Turn random amount up to <var>a</var> degrees. Default
180.
</p> </td></tr><tr class="defn"><td class="dt "><code>"(s)</code> 
 </td><td class="dd "><p>Multiply current length by s. Default Step Size Scale.
</p> </td></tr><tr class="defn"><td class="dt "><code>!(s)</code> 
 </td><td class="dd "><p>Multiply current thickness by s. Default Thickness Scale.
</p> </td></tr><tr class="defn"><td class="dt "><code>;(s)</code> 
 </td><td class="dd "><p>Multiply current angle by s. Default Angle Scale.
</p> </td></tr><tr class="defn"><td class="dt "><code>_(s)</code> 
 </td><td class="dd "><p>Divide current length (underscore) by s. Default Step Size
Scale.
</p> </td></tr><tr class="defn"><td class="dt "><code>?(s)</code> 
 </td><td class="dd "><p>Divides current width by s. Default Thickness Scale.
</p> </td></tr><tr class="defn"><td class="dt "><code>@(s)</code> 
 </td><td class="dd "><p>Divide current angle by s. Default Angle Scale.
</p> </td></tr><tr class="defn"><td class="dt "><code>'(u)</code> 
 </td><td class="dd "><p>Increment color index U by <var>u</var>. Default <strong class="ui">UV Increment</strong>’s
first parameter.
</p> </td></tr><tr class="defn"><td class="dt "><code>#(v)</code> 
 </td><td class="dd "><p>Increment color index V by <var>v</var>. Default <strong class="ui">UV Increment</strong>’s
second parameter.
</p> </td></tr><tr class="defn"><td class="dt "><code>%</code> 
 </td><td class="dd "><p>Cut off remainder of branch
</p> </td></tr><tr class="defn"><td class="dt "><code>$(x,y,z)</code> 
 </td><td class="dd "><p>Rotates the turtle so the up vector is (0,1,0). Points the
turtle in the direction of the point <code>(x,y,z)</code>. Default behavior
is only to orient and not to change the direction.
</p> </td></tr><tr class="defn"><td class="dt "><code>[</code> 
 </td><td class="dd "><p>Push turtle state (start a branch)
</p> </td></tr><tr class="defn"><td class="dt "><code>]</code> 
 </td><td class="dd "><p>Pop turtle state (end a branch)
</p> </td></tr><tr class="defn"><td class="dt "><code>{</code> 
 </td><td class="dd "><p>Start a polygon
</p> </td></tr><tr class="defn"><td class="dt "><code>.</code> 
 </td><td class="dd "><p>Make a polygon vertex
</p> </td></tr><tr class="defn"><td class="dt "><code>}</code> 
 </td><td class="dd "><p>End a polygon
</p> </td></tr><tr class="defn"><td class="dt "><code>g(i)</code> 
 </td><td class="dd "><p>Create a new primitive group to which subsequent geometry is
added. The group name is the Group Prefix followed by the number
<var>i</var>. The default if no parameter is given is to create a group
with the current group number and then increment the current
group number.
</p> </td></tr><tr class="defn"><td class="dt "><code>a(attrib, v1, v2, v3)</code> 
 </td><td class="dd "><p>This creates a point attribute of the name attrib. It is then
set to the value <code>v1, v2, v3</code> for the remainder of the points on
this branch, or until another a command resets it. <var>v2</var> and
<var>v3</var> are optional. If they are not present, an attribute of
fewer floats will be created. The created attribute is always of
float type and with zero defaults. For example, the rule
<code>a("Cd", 1, 0, 1)</code> added to the start of the premise will make
the L-system a nice pugnacious purple.
</p> </td></tr></tbody></table> </div></div><div class="heading" id="id446638"><h2>Use modeled geometry in an L-system</h2><div class="headingcontent"><p>Houdini lets you create a copy of some geometry at the turtle’s location
using certain commands. You can use this to create leaves and flowers on
an L-system shrub, for example.
</p><steps><ol><li><p><a href="http://www.sidefx.com/docs/houdini12.0/ref/panes/network">Connect</a>  the output of the geometry you want to
stamp to one of the L-system node’s inputs.
</p></li><li><p>Use the corresponding command (<code>J</code>, <code>K</code>, or <code>M</code>) in a turtle
command string to insert the geometry.
</p></li></ol></steps><table class="normal"><tbody><tr><th> Input</th><th> Turtle command</th></tr><tr><td> 1</td><td> J</td></tr><tr><td> 2</td><td> K</td></tr><tr><td> 3</td><td> M</td></tr></tbody></table><div class="heading" id="id419234"><h3>Example</h3><div class="headingcontent"><p>If you connect a leaf surface to the L-systems input 1 and a flower
to input 2, you can use the following to create a bush with leaves
and flowers:
</p><table class="normal"><tbody><tr><td> Premise</td><td><p><code>A</code>
</p></td></tr><tr><td> Rule 1</td><td><p><code>A= [&amp;FA [fK]] ///// [&amp;FA [fJ]] /////// [&amp;FA [fJ]]</code>
</p></td></tr><tr><td> Rule 2</td><td><p><code>F= S/////</code>
</p></td></tr><tr><td> Rule 3</td><td><p><code>S= F</code>
</p></td></tr></tbody></table><p><span class=""><img src="./L-system_files/Houdini-03-1-104.jpg" title="" class=""></span>
</p><p>Rule 1 prefaces the <code>K</code> and <code>J</code> commands with <code>f</code> (move forward
without drawing) to offset the geometry a little bit. Otherwise, the
leaf would be attached at its center, rather than the edge.
</p> </div></div> </div></div><div class="heading" id="id391677"><h2>Advanced L-systems information</h2><div class="headingcontent"><div class="heading" id="id391686"><h3>Symbol variables</h3><div class="headingcontent"><p>Each symbol can have up to five user-defined variables associated
with it. You can reference or assign these variables in expressions.
Variables in the matched symbol are instanced while variables in the
replacement are assigned.
</p><p>For example, the rule <code>A(i, j)=A(i+1, j-1)</code> will replace each <code>A</code>
with a new <code>A</code> in which the first parameter (<code>i</code>) has been
incremented and the second parameter (<code>j</code>) decremented.
</p><p>Parameters assigned to geometric symbols (for example, <code>F</code>, <code>+</code>, and
<code>!</code>) are interpreted geometrically. For example, the rule: <code>F(i, j)
= F(0.5*i, 2*j)</code> will again replace each F with a new F containing
modified parameters. In addition to this, the new F will now be
drawn at half the length and twice the width.
</p><div class="alert tip"><p class="alerttitle">Tip <span>
 </span></p><div class="alertcontent"><p>The variables in the predecessor can also be referenced by the
condition or probability portions of the rule. For example, the
rule <code>A(i):i&lt;5 = A(i+1) A(i+1)</code> will double each A a maximum of
five times (assuming a premise of <code>A(0)</code>).
</p> </div></div> </div></div><div class="heading" id="id402683"><h3>Control length over time</h3><div class="headingcontent"><p>To create an L-system which goes forward <var>x</var> percent less on each
iteration, you need to start your Premise with a value, and then in
a rule multiply that value by the percentage you want to remain.
</p><table class="normal"><tbody><tr><td>Premise</td><td><code>A(1)</code></td></tr><tr><td>Rule</td><td><code>A(i)= F(i)A(i*0.5)</code></td></tr></tbody></table><p>This way <var>i</var> is scaled before <var>A</var> is re-evaluated. The important
part is the premise: you need to start with a value to be able to
scale it.
</p> </div></div><div class="heading" id="id423991"><h3>Stamp variables onto input geometry</h3><div class="headingcontent"><p>The third argument to the <code>J</code>/<code>K</code>/<code>M</code> commands is passed to the
connected geometry.
</p><div class="alert tip"><p class="alerttitle">Tip <span>
 </span></p><div class="alertcontent"><p>You can use this trick to get around the limitation of only
three geometry inputs on a L-system.
</p><p>Create all the different models you want (say, 20 different
types of leaves) and connect them to a <a href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/switch">Switch
node</a>. Set the switch node’s <strong class="ui">Select input</strong>
parameter to <code>param("lsys",0)</code>.
</p><p>Connect the switch node to the J input of an L-system node. Now
you can insert any of the 20 leaf types using
<code>J(,,<var>leaf_number</var>)</code>.
</p> </div></div><div class="heading" id="id433516"><h4>Example</h4><div class="headingcontent"><steps><ol><li><p>Create a <a href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/circle">Circle node</a> and set the number
of divisions to <code>param("lsys", 3)</code>.
</p><p>Because the default number of divisions is 3 (the second
argument in the expression), this creates a triangle.
</p></li><li><p>Connect the output of the circle node to the J input of an
L-system node.
</p></li><li><p>In the L-system rules, you can use <code>J(,,<var>number</var>)</code> to
pass <var>number</var> to the J geometry. For example, <code>J(,,4)</code>
produces a square, <code>J(,,5)</code> produces a pentagram.
</p></li></ol></steps> </div></div> </div></div><div class="heading" id="id513906"><h3>Create groups within L-systems</h3><div class="headingcontent"><p>The <code>g</code> command puts all geometry currently being built into a
group.
</p><p>The group name is composed of a prefix set on the <strong class="ui">Funcs</strong> tab and
a number. Default prefix is <code>lsys</code>, producing group names like
“lsys1”. You can specify the number as an argument to the <code>g</code>
command.
</p><p>For example, <code>g[F]</code> puts geometry from the <code>F</code> into a group (named
using ). Otherwise, the default index is incremented appropriately.
</p><p>The current group is associated with the branch, so you can do
things like <code>gF [ gFF ] F</code> to put the first and last <code>F</code> into group
0, and the middle (branched) <code>FF</code> into group 1.
</p><p>To exclude a branch from its parent’s group, use <code>g(-1)</code>.
</p> </div></div><div class="heading" id="id481112"><h3>Edge rewriting</h3><div class="headingcontent"><p>In <em>The Algorithmic Beauty of Plants</em>, many examples use a technique
called <em>edge rewriting</em> which involve left and right subscripts. A
typical example is:
</p><table class="normal"><tbody><tr><td>Generations</td><td><code>10</code></td></tr><tr><td>Angle</td><td><code>90</code></td></tr><tr><td>Premise</td><td><code>F(l)</code></td></tr><tr><td>Rule 1</td><td><code>F(l) = F(l)+F(r)+</code></td></tr><tr><td>Rule 2</td><td><code>F(r)=-F(l)-F(r)</code></td></tr></tbody></table><p>However, Houdini doesn’t support the <code>F(l)</code> and <code>F(r)</code> syntax. You
can modify the rules to use symbol variables instead.
</p><p>For the F turtle symbol, the first four parameters are <var>length</var>,
<var>width</var>, <var>tubesides</var>, and <var>tubesegs</var>. The last parameter is
user-definable. We can define this last parameter so 0 is left, and
1 is right:
</p><table class="normal"><tbody><tr><td>Generations</td><td><code>10</code></td></tr><tr><td>Angle</td><td><code>90</code></td></tr><tr><td>Premise</td><td><code>F(1,1,3,3,0)</code></td></tr><tr><td>Rule 1</td><td><code>F(i,j,k,l,m) :m=0 = F(i,j,k,l,0)+F(i,j,k,l,1)+</code></td></tr><tr><td>Rule 2</td><td><code>F(i,j,k,l,m) :m=1 =-F(i,j,k,l,0)-F(i,j,k,l,1)</code></td></tr></tbody></table><p>After two generations this produces: <code>Fl+Fr+-Fl-Fr</code> There should not
be any difference between this final string and: <code>F+F+-F-F</code>
</p><p>Another approach is to use two new variables, and use a conditional
statement on the final step to convert them to F:
</p><table class="normal"><tbody><tr><td>b</td><td><code>ch("generations")</code></td></tr><tr><td>Premise</td><td><code>l</code></td></tr><tr><td>Rule 1</td><td><code>l:t&lt;b=l+r+</code></td></tr><tr><td>Rule 2</td><td><code>r:t&lt;b=-l-r</code></td></tr><tr><td>Rule 3</td><td><code>l=F</code></td></tr><tr><td>Rule 4</td><td><code>r=F</code></td></tr></tbody></table><p>The produces the following output:
</p><table class="normal"><tbody><tr><th>Generation</th><th>String</th></tr><tr><td>0</td><td><code>l</code></td></tr><tr><td>1</td><td><code>F</code></td></tr><tr><td>2</td><td><code>F+F+</code></td></tr><tr><td>3</td><td><code>F+F++-F-F+</code></td></tr></tbody></table> </div></div><div class="heading" id="id584793"><h3>Limit L-system growth inside a shape</h3><div class="headingcontent"><p>The L-system node’s meta-test input lets you generate rules that will
cause the system to stop when it reaches the edges of a defined shape,
like a topiary hedge.
</p><steps><ol><li><p>Create a metaball or merged metaballs that define the volume in
which the L-system can grow.
</p></li><li><p>Connect the metaball node’s output to the Meta-test input of the
L-system node.
</p></li><li><p>Use a conditional statement (<code>:</code>) with an “in” test. For example
</p></li></ol></steps><div class="heading" id="id585686"><h4>Example</h4><div class="headingcontent"><table class="normal"><tbody><tr><td> Premise</td><td><p><code>FA</code>
</p></td></tr><tr><td> Rule 1</td><td><p><code>A: in(x,y,z) = F [+FA] -FA : 80</code>
</p></td></tr><tr><td> Rule 2</td><td><p><code>A: ! in(x,y,z) = A%</code>
</p></td></tr></tbody></table><ul><li><p>This L-system checks to see if the next iteration of growth will
be within the Meta-test bounds, and if not it prunes the current
branch.
</p></li><li><p>Rule 1 executes 80% of the time when the branch is within the
meta-test boundary.
</p></li><li><p>Rule 2 executes when the branch is <em>not</em> within the meta-test
boundary (the <code>!</code> negates the <code>in(x,y,z)</code> condition). The <code>%</code>
command ends the branch.
</p></li></ul> </div></div><div class="alert note"><p class="alerttitle">Note <span>
 </span></p><div class="alertcontent"><p>If the L-system start point is not inside the metaball envelope, it
will stay dormant. Once you have set up your L-system and metaballs,
make sure you transform them together so the L-system is not
accidentally moved outside the metaball.
</p> </div></div> </div></div><div class="heading" id="id465626"><h3>Arrange geometry instances with L-systems</h3><div class="headingcontent"><p>L-systems can be a powerful tool for arranging modeled geometry. By
using an L-system as the template input to a <a href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/copy">Copy SOP</a>,
you can place a copy of a model at every point of the L-system.
</p><p>For example, you could use the “arc approximation” L-system from the
<a href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/#basics">L-system basics</a>  (premise=<code>A</code>, rule=<code>A=F+A</code>) to arrange
a series of spheres in an arc or circle. This gives you parametric
control of the bending and spacing of the arc of spheres.
</p> </div></div> </div></div><div class="heading" id="id475345"><h2>Further reading</h2><div class="headingcontent"><p>If you have any serious interests in creating L-systems, you should
obtain the book:
</p><p><em>The Algorithmic Beauty of Plants</em> by Przemyslaw Prusinkiewicz and
Aristid Lindenmayer (1996, Springer-Verlag, New York. Phone
212.460.1500. ISBN: 0-387-94676-4)
</p><p>It is the definitive work on the subject. It contains many L-systems
examples along with ideas and theories about modeling realistic
plant growth.
</p> </div></div><div class="heading" id="id568939"><h2>Speed up calculations</h2><div class="headingcontent"><p>Modeling something like a whole tree as single large L-System may cause collision resolution calculations to be single threaded. The wire solver will look for pieces of wire objects that can be solved independently and divide the work among the available cores. One large connected L-System means the work cannot be divided into smaller work units.
</p><p>Try using a <a href="http://www.sidefx.com/docs/houdini12.0/nodes/dop/wireglueconstraint">Wire Glue Constraint DOP</a> to constrain a point on the L-System where the branches join together near the root of the tree (constrain the point to its world space position). This will cause the wire solver to see the separate branches as distinct pieces that can be solved independently. Since the constrained point will not move, any motion on one of the branches will not affect the other branches. If possible, reducing the number of points in the wire object should also speed up the calculations. 
</p> </div></div><div id="parameters" class="section"><h2 class="section">Parameters</h2><div class="heading" id="id545742"><h3>Geometry</h3><div class="headingcontent"><table class="defntable"><tbody><tr class="defn"><td class="dt " id="type">Type
 </td><td class="dd "><p>The type of geometry to create as the turtle moves.
</p><div class="alert tip"><p class="alerttitle">Tip <span>
 </span></p><div class="alertcontent"><p>You can create a tube path from a skeleton L-system using
a <a href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/polywire">Polywire SOP</a>.
</p> </div></div><table class="defntable"><tbody><tr class="defn"><td class="dt " id="skeleton">Skeleton
 </td><td class="dd "><p>Draw polylines.
</p> </td></tr><tr class="defn"><td class="dt " id="tube">Tube
 </td><td class="dd "><p>Draw tubes.
</p> </td></tr></tbody></table> </td></tr><tr class="defn"><td class="dt " id="generations">Generations
 </td><td class="dd "><p>The number of times to repeat the rule-substitution. If you
specify a fractional number and <strong class="ui">Continuous angles</strong> and/or
<strong class="ui">Continuous length</strong> are on (below), Houdini scales the
geometry generated by the last substitution to give smooth
growth between generations.
</p> </td></tr><tr class="defn"><td class="dt " id="start_position">Start Position
 </td><td class="dd "><p>This is the starting point position for the turtle.
</p> </td></tr><tr class="defn"><td class="dt " id="random_scale">Random Scale
 </td><td class="dd "><p>If non-zero, randomly scales all the lengths specified by F
and other similar turtle functions.
</p> </td></tr><tr class="defn"><td class="dt " id="random_seed">Random Seed
 </td><td class="dd "><p>The seed to use for the random number generator. By varying
this on a L-system using random rules (Ie: random scale, ~,
or probabilistic rules) one can generate different instances
of the L-system.
</p> </td></tr><tr class="defn"><td class="dt " id="continuous_angles">Continuous Angles
 </td><td class="dd "><p>If set, the angles rotated by the last generation’s turtle
operations will be scaled by the amount into the
generation.
</p> </td></tr><tr class="defn"><td class="dt " id="continuous_length">Continuous Length
 </td><td class="dd "><p>If set, the lengths taken by the last generation’s turtle
operations will be scaled by the amount into the
generation.
</p> </td></tr><tr class="defn"><td class="dt " id="continuous_width">Continuous Width
 </td><td class="dd "><p>If set, the widths generated by the last generation’s turtle
operations will be scaled by the amount into the
generation.
</p> </td></tr><tr class="defn"><td class="dt " id="apply_color">Apply Color
 </td><td class="dd "><p>If set, the L-system will output a color attribute on each
point. The color value will be found by looking up into the
Image File at the current U &amp; V positions. The current U &amp; V
is altered with the ' and # turtle operations.
</p> </td></tr><tr class="defn"><td class="dt " id="image_file">Image File
 </td><td class="dd "><p>This is the image file which is used for the Apply Color
operation. The image files used by the pic() expression is
under Funcs tab.
</p> </td></tr><tr class="defn"><td class="dt " id="uv_increment">UV Increment
 </td><td class="dd "><p>These determine the default U and V increments of the ' and
</p><ol><li><p>turtle operations.
</p></li></ol> </td></tr><tr class="defn"><td class="dt " id="point_attributes">Point Attributes
 </td><td class="dd "><p>If the type is Skeleton, this is available. Turning this on
will cause the creation of many point attributes to be
created to track how each point was generated:
</p><table class="defntable"><tbody><tr class="defn"><td class="dt " id="width">width
 </td><td class="dd "><p>The width of the tube that would have been generated.
</p> </td></tr><tr class="defn"><td class="dt " id="segs">segs
 </td><td class="dd "><p>The number of segments that would be made on a tube.
</p> </td></tr><tr class="defn"><td class="dt " id="div">div
 </td><td class="dd "><p>The number of divisions the tube would be divided into.
</p> </td></tr><tr class="defn"><td class="dt " id="lage">lage
 </td><td class="dd "><p>The vertical increment from the root of the tree. This
is affected by the Tube::Vertical Increment parameter.
It is similar to arc, but not dependent on edge length.
</p> </td></tr><tr class="defn"><td class="dt " id="arc">arc
 </td><td class="dd "><p>The arc length from the root of the turtles path to this
point.
</p> </td></tr><tr class="defn"><td class="dt " id="up">up
 </td><td class="dd "><p>The up vector of the turtle at this point.
</p> </td></tr><tr class="defn"><td class="dt " id="gen">gen
 </td><td class="dd "><p>The generation that created this point.
</p> </td></tr></tbody></table> </td></tr></tbody></table> </div></div><div class="heading" id="id395136"><h3>Tube</h3><div class="headingcontent"><table class="defntable"><tbody><tr class="defn"><td class="dt " id="rows">Rows
 </td><td class="dd "><p>The number of rows to divide tubes into. A value of 3 will
cause the tubes to be swept triangles.
</p> </td></tr><tr class="defn"><td class="dt " id="cols">Cols
 </td><td class="dd "><p>The number of columns to divide the tubes in. A value of 4
means one F will create 4 cross sections.
</p> </td></tr><tr class="defn"><td class="dt " id="tension">Tension
 </td><td class="dd "><p>How straight the tubes should sweep to their destination
point.
</p> </td></tr><tr class="defn"><td class="dt " id="branch_blend">Branch Blend
 </td><td class="dd "><p>How much a new branch should inherit off an old branches
direction.
</p> </td></tr><tr class="defn"><td class="dt " id="thickness">Thickness
 </td><td class="dd "><p>Default width of the tubes.
</p> </td></tr><tr class="defn"><td class="dt " id="thickness_scale">Thickness Scale
 </td><td class="dd "><p>How much the ! operation will affect the thickness.
</p> </td></tr><tr class="defn"><td class="dt " id="7RdotE4TvriKHm1-aJy6Kg==">Apply Tube Texture Coordinates
 </td><td class="dd "><p>If checked, the tubes will generate uv texture coordinates.
</p> </td></tr><tr class="defn"><td class="dt " id="vertical_increment">Vertical Increment
 </td><td class="dd "><p>The amount each tube will increment the V texture
coordinate.
</p> </td></tr></tbody></table> </div></div><div class="heading" id="id568205"><h3>Values</h3><div class="headingcontent"><table class="defntable"><tbody><tr class="defn"><td class="dt " id="step_size">Step Size
 </td><td class="dd "><p>The default size of a movement, such as F, command.
</p> </td></tr><tr class="defn"><td class="dt " id="step_size_scale">Step Size Scale
 </td><td class="dd "><p>The number used by the “ command.
</p> </td></tr><tr class="defn"><td class="dt " id="angle">Angle
 </td><td class="dd "><p>The default angle for an angle, such as /, command. This
also becomes the variable a in the expression.
</p> </td></tr><tr class="defn"><td class="dt " id="angle_scale">Angle Scale
 </td><td class="dd "><p>The number used by the ; command.
</p> </td></tr><tr class="defn"><td class="dt " id="variable_b">Variable b
 </td><td class="dd "><p>The value of the expression variable b.
</p> </td></tr><tr class="defn"><td class="dt " id="variable_c">Variable c
 </td><td class="dd "><p>The value of the expression variable c.
</p> </td></tr><tr class="defn"><td class="dt " id="variable_d">Variable d
 </td><td class="dd "><p>The value of the expression variable d.
</p> </td></tr><tr class="defn"><td class="dt " id="gravity">Gravity
 </td><td class="dd "><p>The amount of tropism from the T command. Also becomes the
value of the expression variable T.
</p> </td></tr><tr class="defn"><td class="dt " id="number_of_variables">Number Of Variables
 </td><td class="dd "><p>This multiparm allows the assignment of an arbitrary number
of new expression variables.
</p> </td></tr><tr class="defn"><td class="dt " id="variable_name">Variable Name
 </td><td class="dd "><p>The name of the expression variable. This is a single
character. Check the Local Variables section to see what
variables are already reserved.
</p> </td></tr><tr class="defn"><td class="dt " id="variable_value">Variable Value
 </td><td class="dd "><p>The value of the expression variable.
</p> </td></tr></tbody></table> </div></div><div class="heading" id="id568219"><h3>Funcs</h3><div class="headingcontent"><table class="defntable"><tbody><tr class="defn"><td class="dt " id="pic_image_file">Pic Image File
 </td><td class="dd "><p>The image file to use with the pic() expression function.
</p> </td></tr><tr class="defn"><td class="dt " id="group_prefix">Group Prefix
 </td><td class="dd "><p>The prefix used by g command.
</p> </td></tr><tr class="defn"><td class="dt " id="channel_prefix">Channel Prefix
 </td><td class="dd "><p>The prefix used by the chan() expression function.
</p> </td></tr><tr class="defn"><td class="dt " id="leaf_param_a">Leaf Param A
 </td><td class="dd "><p>This is the name of the stamp parameter to stamp the leaf
with. The value of the stamp comes from the J, K, or M
operation. It can be read upstream using the param()
function.
</p> </td></tr><tr class="defn"><td class="dt " id="leaf_param_b">Leaf Param B
 </td><td class="dd "><p>This is the name of the stamp parameter to stamp the leaf
with. The value of the stamp comes from the J, K, or M
operation. It can be read upstream using the param()
function.
</p> </td></tr><tr class="defn"><td class="dt " id="leaf_param_c">Leaf Param C
 </td><td class="dd "><p>This is the name of the stamp parameter to stamp the leaf
with. The value of the stamp comes from the J, K, or M
operation. It can be read upstream using the param()
function.
</p> </td></tr></tbody></table> </div></div><div class="heading" id="id494956"><h3>Rules</h3><div class="headingcontent"><table class="defntable"><tbody><tr class="defn"><td class="dt " id="read_rules_from_file">Read Rules From File
 </td><td class="dd "><p>If this is set, the rule fields are ignored. Instead, the
Rule File is read and used as the rules.
</p> </td></tr><tr class="defn"><td class="dt " id="pMwanWjOMMvWnbfTYeIqjw==">Write Rule Parameters to File
 </td><td class="dd "><p>This will write all the current rules to the Rule File.
</p> </td></tr><tr class="defn"><td class="dt " id="rule_file">Rule File
 </td><td class="dd "><p>The name of the file to use as a source of rules. This file
should have one line per rule. Blank lines and lines that
start with '#' will be ignored, so comments may be added to
the rule file with '#'.
</p> </td></tr><tr class="defn"><td class="dt " id="context_ignore">Context Ignore
 </td><td class="dd "><p>This is a list of symbols. They will be ignored when trying
to determine contexts.
</p> </td></tr><tr class="defn"><td class="dt " id="4lEsUbaL2cL9StAx3BCIDA==">Context Includes Siblings
 </td><td class="dd "><p>By default, the context of each branch only includes the
symbols in that branch.  Any sub-branches or parent
branches will be skipped over.  Given the rule <code>A&gt;B=F</code>, <code>A[B]</code>
will not resolve as B is in a sub-branch.  <code>A[Q]B</code> will
resolve because the <code>[Q]</code> is ignored.  If you change the
Context Ignore to have <code>[]</code>, this effect is removed and
<code>A[Q]B</code> will not resolve but <code>A[B]</code> will.  The Context
Includes Siblings flag restores the pre-Houdini 10
behaviour of context of sibling branches being included.
For example, <code>[A]Q[B]</code> will resolve if this flag is set, but
not resolve if it is not set.
</p> </td></tr><tr class="defn"><td class="dt " id="premise">Premise
 </td><td class="dd "><p>The initial state of the L-system. This is the state of the
L-system at generation 0.
</p> </td></tr><tr class="defn"><td class="dt " id="rule_">Rule #
 </td><td class="dd "><p>A rule to apply to the L-system.  Applying the toggle will disable
the rule, removing it from the generation procedure.
</p> </td></tr></tbody></table> </div></div></div><div id="inputs" class="section"><h2 class="section">Inputs</h2><table class="dl"><tbody><tr class="defn"><td class="dt ">Leaf J,K &amp; M
 </td><td class="dd "><p>This geometry is used by the J, K &amp; M rules
</p> </td></tr><tr class="defn"><td class="dt ">Meta Test Input
 </td><td class="dd "><p>This geometry is used by the in() function to determine bounding
regions (for topiaries)
</p> </td></tr></tbody></table></div><div id="locals" class="section"><h2 class="section">Local variables</h2><table class="dl"><tbody><tr class="defn"><td class="dt ">a
 </td><td class="dd "><p>The value of the <strong class="ui">Angle</strong> parameter.
</p> </td></tr><tr class="defn"><td class="dt ">b
 </td><td class="dd "><p>The value of the <strong class="ui">b</strong> parameter.
</p> </td></tr><tr class="defn"><td class="dt ">c
 </td><td class="dd "><p>The value of the <strong class="ui">c</strong> parameter.
</p> </td></tr><tr class="defn"><td class="dt ">d
 </td><td class="dd "><p>The value of the <strong class="ui">d</strong> parameter.
</p> </td></tr><tr class="defn"><td class="dt ">g
 </td><td class="dd "><p>The age of the current rule, initially 0.
</p> </td></tr><tr class="defn"><td class="dt ">i
 </td><td class="dd "><p>The offset into the current L-system string where the rule is
being applied.
</p> </td></tr><tr class="defn"><td class="dt ">t
 </td><td class="dd "><p>The iteration count, initially 0.
</p> </td></tr><tr class="defn"><td class="dt ">x, y, z
 </td><td class="dd "><p>Current turtle position in space.
</p> </td></tr><tr class="defn"><td class="dt ">A
 </td><td class="dd "><p>Arclength from the root of the tree to the current point.
</p> </td></tr><tr class="defn"><td class="dt ">L
 </td><td class="dd "><p>Current length increment at the point.
</p> </td></tr><tr class="defn"><td class="dt ">T
 </td><td class="dd "><p>The value of the <strong class="ui">Gravity</strong> parameter.
</p> </td></tr><tr class="defn"><td class="dt ">U
 </td><td class="dd "><p>Color map U value.
</p> </td></tr><tr class="defn"><td class="dt ">V
 </td><td class="dd "><p>Color map V value.
</p> </td></tr><tr class="defn"><td class="dt ">W
 </td><td class="dd "><p>Width at the current point.
</p> </td></tr></tbody></table></div><div id="examples"> <h2 class="section">Examples</h2><table class="examplestable"><tbody><tr><td class="examplelink"><a href="http://www.sidefx.com/docs/houdini12.0/examples/nodes/sop/lsystem/LSystemMaster" title="">LSystemMaster</a> </td><td class="exampleload"><strong><a href="javascript:loadExample('/examples/nodes/sop/lsystem/LSystemMaster.otl',false)">Load</a></strong> | <a href="javascript:loadExample('/examples/nodes/sop/lsystem/LSystemMaster.otl',true)">Launch</a> </td></tr><tr><td colspan="2" class="exampletext"><p><code>.../examples/nodes/sop/lsystem/LSystemMaster.otl</code></p><p>The LSystems SOP allows for the definition of complex shapes through the use of iteration. It uses a mathematical language in which an initial string of characters is evaluated repeatedly, and the results are used to generate geometry. The result of each evaluation becomes the basis for the next iteration of geometry, giving the illusion of growth.
</p><p>The example networks located in this demonstration should be enough to get you started writing custom LSystem rules. 
</p><p>However, anyone seriously interested in creating LSystems should obtain the book:
</p><p><em>The Algorithmic Beauty of Plants</em>,
Przemyslaw Prusinkiewicz and Aristid Lindenmayer
</p><p>For a full list of LSystem commands, see the Houdini documentation. 
</p></td></tr></tbody></table><h2>Examples that use this node</h2><table class="examplestable"><tbody><tr><th>Example for</th><th>Example name</th><th></th></tr><tr><td class="examplefor"><a href="http://www.sidefx.com/docs/houdini12.0/nodes/dop/applyrel" title="Creates relationships between simulation objects.">Apply Relationship</a></td><td class="examplelink"><a href="http://www.sidefx.com/docs/houdini12.0/examples/nodes/dop/applyrel/ApplyRelationship" title="">ApplyRelationship</a> </td><td class="exampleload"><strong><a href="javascript:loadExample('/examples/nodes/dop/applyrel/ApplyRelationship.otl',false)">Load</a></strong> | <a href="javascript:loadExample('/examples/nodes/dop/applyrel/ApplyRelationship.otl',true)">Launch</a> </td></tr><tr><td colspan="3" class="exampletext"><p><code>.../examples/nodes/dop/applyrel/ApplyRelationship.otl</code></p></td></tr><tr><td class="examplefor"><a href="http://www.sidefx.com/docs/houdini12.0/nodes/dop/flipsolver" title="Evolves an object as a FLIP fluid object.">FLIP Solver</a></td><td class="examplelink"><a href="http://www.sidefx.com/docs/houdini12.0/examples/nodes/dop/flipsolver/FlipFluidWire" title="">FlipFluidWire</a> </td><td class="exampleload"><strong><a href="javascript:loadExample('/examples/nodes/dop/flipsolver/FlipFluidWire.otl',false)">Load</a></strong> | <a href="javascript:loadExample('/examples/nodes/dop/flipsolver/FlipFluidWire.otl',true)">Launch</a> </td></tr><tr><td colspan="3" class="exampletext"><p><code>.../examples/nodes/dop/flipsolver/FlipFluidWire.otl</code></p></td></tr><tr><td class="examplefor"><a href="http://www.sidefx.com/docs/houdini12.0/nodes/dop/fluidforce" title="Applies forces to resist the current motion of soft body objects relative to a fluid.">Fluid Force</a></td><td class="examplelink"><a href="http://www.sidefx.com/docs/houdini12.0/examples/nodes/dop/fluidforce/FluidWireInteraction" title="">FluidWireInteraction</a> </td><td class="exampleload"><strong><a href="javascript:loadExample('/examples/nodes/dop/fluidforce/FluidWireInteraction.otl',false)">Load</a></strong> | <a href="javascript:loadExample('/examples/nodes/dop/fluidforce/FluidWireInteraction.otl',true)">Launch</a> </td></tr><tr><td colspan="3" class="exampletext"><p><code>.../examples/nodes/dop/fluidforce/FluidWireInteraction.otl</code></p></td></tr><tr><td class="examplefor"><a href="" title=""></a></td><td class="examplelink"><a href="http://www.sidefx.com/docs/houdini12.0/examples/nodes/dop/grassDeforms/grass" title="">grass</a> </td><td class="exampleload"><strong><a href="javascript:loadExample('/examples/nodes/dop/grassDeforms/grass.otl',false)">Load</a></strong> | <a href="javascript:loadExample('/examples/nodes/dop/grassDeforms/grass.otl',true)">Launch</a> </td></tr><tr><td colspan="3" class="exampletext"><p><code>.../examples/nodes/dop/grassDeforms/grass.otl</code></p></td></tr><tr><td class="examplefor"><a href="http://www.sidefx.com/docs/houdini12.0/nodes/dop/wireglueconstraint" title="Constraints a wire point to a certain position and direction.">Wire Glue Constraint</a></td><td class="examplelink"><a href="http://www.sidefx.com/docs/houdini12.0/examples/nodes/dop/wireglueconstraint/AnimatedSkin" title="">AnimatedSkin</a> </td><td class="exampleload"><strong><a href="javascript:loadExample('/examples/nodes/dop/wireglueconstraint/AnimatedSkin.otl',false)">Load</a></strong> | <a href="javascript:loadExample('/examples/nodes/dop/wireglueconstraint/AnimatedSkin.otl',true)">Launch</a> </td></tr><tr><td colspan="3" class="exampletext"><p><code>.../examples/nodes/dop/wireglueconstraint/AnimatedSkin.otl</code></p></td></tr><tr><td class="examplefor"><a href="http://www.sidefx.com/docs/houdini12.0/nodes/dop/wireobject" title="Creates a Wire Object from SOP Geometry.">Wire Object</a></td><td class="examplelink"><a href="http://www.sidefx.com/docs/houdini12.0/examples/nodes/dop/wireobject/CompressedSpring" title="">CompressedSpring</a> </td><td class="exampleload"><strong><a href="javascript:loadExample('/examples/nodes/dop/wireobject/CompressedSpring.otl',false)">Load</a></strong> | <a href="javascript:loadExample('/examples/nodes/dop/wireobject/CompressedSpring.otl',true)">Launch</a> </td></tr><tr><td colspan="3" class="exampletext"><p><code>.../examples/nodes/dop/wireobject/CompressedSpring.otl</code></p></td></tr><tr><td class="examplefor"><a href="http://www.sidefx.com/docs/houdini12.0/nodes/dop/wiresolver" title="Sets and configures a Wire solver.">Wire Solver</a></td><td class="examplelink"><a href="http://www.sidefx.com/docs/houdini12.0/examples/nodes/dop/wiresolver/BeadCurtain" title="">BeadCurtain</a> </td><td class="exampleload"><strong><a href="javascript:loadExample('/examples/nodes/dop/wiresolver/BeadCurtain.otl',false)">Load</a></strong> | <a href="javascript:loadExample('/examples/nodes/dop/wiresolver/BeadCurtain.otl',true)">Launch</a> </td></tr><tr><td colspan="3" class="exampletext"><p><code>.../examples/nodes/dop/wiresolver/BeadCurtain.otl</code></p></td></tr><tr><td class="examplefor"><a href="http://www.sidefx.com/docs/houdini12.0/nodes/dop/wiresolver" title="Sets and configures a Wire solver.">Wire Solver</a></td><td class="examplelink"><a href="http://www.sidefx.com/docs/houdini12.0/examples/nodes/dop/wiresolver/BendingTree" title="">BendingTree</a> </td><td class="exampleload"><strong><a href="javascript:loadExample('/examples/nodes/dop/wiresolver/BendingTree.otl',false)">Load</a></strong> | <a href="javascript:loadExample('/examples/nodes/dop/wiresolver/BendingTree.otl',true)">Launch</a> </td></tr><tr><td colspan="3" class="exampletext"><p><code>.../examples/nodes/dop/wiresolver/BendingTree.otl</code></p></td></tr><tr><td class="examplefor"><a href="http://www.sidefx.com/docs/houdini12.0/nodes/dop/wiresolver" title="Sets and configures a Wire solver.">Wire Solver</a></td><td class="examplelink"><a href="http://www.sidefx.com/docs/houdini12.0/examples/nodes/dop/wiresolver/BreakWire" title="">BreakWire</a> </td><td class="exampleload"><strong><a href="javascript:loadExample('/examples/nodes/dop/wiresolver/BreakWire.otl',false)">Load</a></strong> | <a href="javascript:loadExample('/examples/nodes/dop/wiresolver/BreakWire.otl',true)">Launch</a> </td></tr><tr><td colspan="3" class="exampletext"><p><code>.../examples/nodes/dop/wiresolver/BreakWire.otl</code></p></td></tr><tr><td class="examplefor"><a href="http://www.sidefx.com/docs/houdini12.0/nodes/dop/wiresolver" title="Sets and configures a Wire solver.">Wire Solver</a></td><td class="examplelink"><a href="http://www.sidefx.com/docs/houdini12.0/examples/nodes/dop/wiresolver/CurveAdvection" title="">CurveAdvection</a> </td><td class="exampleload"><strong><a href="javascript:loadExample('/examples/nodes/dop/wiresolver/CurveAdvection.otl',false)">Load</a></strong> | <a href="javascript:loadExample('/examples/nodes/dop/wiresolver/CurveAdvection.otl',true)">Launch</a> </td></tr><tr><td colspan="3" class="exampletext"><p><code>.../examples/nodes/dop/wiresolver/CurveAdvection.otl</code></p></td></tr><tr><td class="examplefor"><a href="http://www.sidefx.com/docs/houdini12.0/nodes/dop/wiresolver" title="Sets and configures a Wire solver.">Wire Solver</a></td><td class="examplelink"><a href="http://www.sidefx.com/docs/houdini12.0/examples/nodes/dop/wiresolver/Footprints" title="">Footprints</a> </td><td class="exampleload"><strong><a href="javascript:loadExample('/examples/nodes/dop/wiresolver/Footprints.otl',false)">Load</a></strong> | <a href="javascript:loadExample('/examples/nodes/dop/wiresolver/Footprints.otl',true)">Launch</a> </td></tr><tr><td colspan="3" class="exampletext"><p><code>.../examples/nodes/dop/wiresolver/Footprints.otl</code></p></td></tr><tr><td class="examplefor"><a href="http://www.sidefx.com/docs/houdini12.0/nodes/dop/wiresolver" title="Sets and configures a Wire solver.">Wire Solver</a></td><td class="examplelink"><a href="http://www.sidefx.com/docs/houdini12.0/examples/nodes/dop/wiresolver/Pendulum" title="">Pendulum</a> </td><td class="exampleload"><strong><a href="javascript:loadExample('/examples/nodes/dop/wiresolver/Pendulum.otl',false)">Load</a></strong> | <a href="javascript:loadExample('/examples/nodes/dop/wiresolver/Pendulum.otl',true)">Launch</a> </td></tr><tr><td colspan="3" class="exampletext"><p><code>.../examples/nodes/dop/wiresolver/Pendulum.otl</code></p></td></tr><tr><td class="examplefor"><a href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/fur" title="Creates a set of hair-like curves across a surface.">Fur</a></td><td class="examplelink"><a href="http://www.sidefx.com/docs/houdini12.0/examples/nodes/sop/fur/FurBallWorkflow" title="">FurBallWorkflow</a> </td><td class="exampleload"><strong><a href="javascript:loadExample('/examples/nodes/sop/fur/FurBallWorkflow.otl',false)">Load</a></strong> | <a href="javascript:loadExample('/examples/nodes/sop/fur/FurBallWorkflow.otl',true)">Launch</a> </td></tr><tr><td colspan="3" class="exampletext"><p><code>.../examples/nodes/sop/fur/FurBallWorkflow.otl</code></p></td></tr></tbody></table></div></div><div id="metadata"> <h2>On this page</h2><ul class="minitoc"><li class="miniheading"><a href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/lsystem#id551994">About L-systems</a></li><li class="miniheading"><a href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/lsystem#includeme">Placing an L-System in the viewer</a><ul><li class="miniheading"><a href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/lsystem#id603486">L-System Handles</a></li></ul></li><li class="miniheading"><a href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/lsystem#basics">L-system basics</a><ul><li class="miniheading"><a href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/lsystem#id472957">Fractal properties</a></li><li class="miniheading"><a href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/lsystem#id593060">Rewriting</a></li><li class="miniheading"><a href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/lsystem#id595662">Production rule syntax</a></li><li class="miniheading"><a href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/lsystem#id532930">Turtle commands</a></li><li class="miniheading"><a href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/lsystem#id534708">Rewriting turtle command strings</a></li><li class="miniheading"><a href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/lsystem#id516060">Branches</a></li><li class="miniheading"><a href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/lsystem#id603489">3D</a></li><li class="miniheading"><a href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/lsystem#id617963">Use multiple L-system rules</a></li></ul></li><li class="miniheading"><a href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/lsystem#id512001">Turtle command reference</a></li><li class="miniheading"><a href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/lsystem#id446638">Use modeled geometry in an L-system</a><ul><li class="miniheading"><a href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/lsystem#id419234">Example</a></li></ul></li><li class="miniheading"><a href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/lsystem#id391677">Advanced L-systems information</a><ul><li class="miniheading"><a href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/lsystem#id391686">Symbol variables</a></li><li class="miniheading"><a href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/lsystem#id402683">Control length over time</a></li><li class="miniheading"><a href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/lsystem#id423991">Stamp variables onto input geometry</a><ul><li class="miniheading"><a href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/lsystem#id433516">Example</a></li></ul></li><li class="miniheading"><a href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/lsystem#id513906">Create groups within L-systems</a></li><li class="miniheading"><a href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/lsystem#id481112">Edge rewriting</a></li><li class="miniheading"><a href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/lsystem#id584793">Limit L-system growth inside a shape</a><ul><li class="miniheading"><a href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/lsystem#id585686">Example</a></li></ul></li><li class="miniheading"><a href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/lsystem#id465626">Arrange geometry instances with L-systems</a></li></ul></li><li class="miniheading"><a href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/lsystem#id475345">Further reading</a></li><li class="miniheading"><a href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/lsystem#id568939">Speed up calculations</a></li><li class="minisection"><strong><a href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/lsystem#parameters">Parameters</a></strong><ul><li class="miniheading"><a href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/lsystem#id545742">Geometry</a></li><li class="miniheading"><a href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/lsystem#id395136">Tube</a></li><li class="miniheading"><a href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/lsystem#id568205">Values</a></li><li class="miniheading"><a href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/lsystem#id568219">Funcs</a></li><li class="miniheading"><a href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/lsystem#id494956">Rules</a></li></ul></li><li class="minisection"><strong><a href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/lsystem#inputs">Inputs</a></strong></li><li class="minisection"><strong><a href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/lsystem#locals">Local variables</a></strong></li><li class="minisection"><strong><a href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/lsystem#examples">Examples</a></strong></li></ul><h2>Related topics</h2><ul id="related"><li class="linkitem" style="list-style-image: url(&quot;../../icons/small/SOP/polywire.png&quot;)"><p><a href="http://www.sidefx.com/docs/houdini12.0/nodes/sop/polywire">Poly Wire</a> <span class="linkdesc">surface node</span></p></li></ul></div></div></div></body></html>